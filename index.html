<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simulador del Sistema Solar 3D Avanzado - Responsive</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
      /* Oculta los controles nativos de los inputs number */
      input[type=number]::-webkit-inner-spin-button,
      input[type=number]::-webkit-outer-spin-button {
          -webkit-appearance: none;
          margin: 0;
      }
      input[type=number] {
          -moz-appearance: textfield;
      }
      body {
          margin: 0;
          overflow: hidden;
          background-color: #000;
          font-family: 'Orbitron', sans-serif;
          color: #fff;
      }
      /* Contenedores globales */
      #globalControls {
          position: fixed;
          top: 10px;
          left: 10px;
          z-index: 1100;
          display: flex;
          gap: 10px;
      }
      #globalParameters {
          position: fixed;
          top: 10px;
          left: 50%;
          transform: translateX(-50%);
          z-index: 1100;
          display: flex;
          flex-direction: column;
          gap: 10px;
          background: rgba(0,0,0,0.7);
          padding: 5px 10px;
          border-radius: 5px;
      }
      /* Div para mostrar el tiempo simulado */
      #simTimeDisplay {
          color: #fff;
          font-size: 0.9em;
          text-align: center;
      }
      #globalActions {
          position: fixed;
          top: 10px;
          right: 10px;
          z-index: 1100;
          display: flex;
          gap: 10px;
      }
      #globalActions button {
          font-size: 1.5em;
          padding: 5px 8px;
          background: transparent;
          border: none;
          color: #4CAF50;
          cursor: pointer;
      }
      #globalActions button:hover {
          color: #45a049;
      }
      /* Panel de controles de par√°metros */
      #controls {
          position: absolute;
          top: 60px;
          left: 20px;
          background: rgba(0,0,0,0.7);
          padding: 20px;
          border-radius: 10px;
          box-shadow: 0 0 20px rgba(255,255,255,0.1);
          width: 400px;
          max-width: 90%;
          max-height: 90vh;
          overflow-y: auto;
          transition: transform 0.3s;
      }
      #controls.hidden {
          transform: translateX(-420px);
      }
      #controls h2 {
          margin-top: 0;
          color: #4CAF50;
          text-align: center;
      }
      label {
          margin-bottom: 10px;
      }
      .planet-control label .fieldName {
          width: 120px;
          display: inline-block;
          text-align: right;
      }
      .planet-control label {
          display: flex;
          align-items: center;
          gap: 5px;
          margin-bottom: 5px;
          font-size: 0.9em;
      }
      input[type="range"],
      input[type="number"],
      input[type="text"] {
          width: 100%;
          margin-top: 5px;
          background: rgba(255,255,255,0.1);
          border: none;
          color: #fff;
          padding: 5px;
          border-radius: 5px;
      }
      button {
          background: #4CAF50;
          color: white;
          border: none;
          padding: 10px 15px;
          margin: 5px 0;
          border-radius: 5px;
          cursor: pointer;
          transition: background 0.3s;
      }
      button:hover {
          background: #45a049;
      }
      /* Ventana de informaci√≥n; se sit√∫a en la parte superior derecha pero m√°s abajo */
      #infoWindow {
          position: fixed;
          top: 100px;
          right: 20px;
          width: 300px;
          background: rgba(0,0,0,0.8);
          border: 1px solid #4CAF50;
          border-radius: 10px;
          padding: 15px;
          color: #fff;
          z-index: 1200;
          display: none;
      }
      #infoWindow h3 {
          margin-top: 0;
      }
      #infoWindow button.closeBtn {
          background: #E53935;
          border: none;
          color: #fff;
          padding: 5px 10px;
          border-radius: 5px;
          cursor: pointer;
          float: right;
      }
      .planet-control {
          border: 1px solid #444;
          padding: 5px;
          margin-bottom: 10px;
          border-radius: 5px;
      }
      .planet-control h3 {
          margin: 0 0 5px 0;
          font-size: 1.1em;
          display: inline-block;
      }
      .planet-control button.focus-btn {
          background: transparent;
          border: none;
          margin-left: 10px;
          cursor: pointer;
          font-size: 1em;
      }
      .planet-control button.reset-default-btn {
          background: transparent;
          border: none;
          cursor: pointer;
          font-size: 1.2em;
          color: #4CAF50;
          margin-left: 5px;
      }
      .planet-control button.reset-default-btn:hover {
          color: #45a049;
      }
      .planet-control button.delete-btn {
          background: #E53935;
          margin-top: 5px;
      }
      .control-group {
          margin-bottom: 15px;
          border-bottom: 1px solid #444;
          padding-bottom: 10px;
      }
      .add-planet {
          border: 1px solid #444;
          padding: 10px;
          border-radius: 5px;
          margin-top: 10px;
      }
      /* Bot√≥n para resetear todos los planetas */
      #resetAllButton {
          background: #E53935;
          color: white;
          border: none;
          padding: 10px 15px;
          margin: 5px 0;
          border-radius: 5px;
          cursor: pointer;
          transition: background 0.3s;
          width: 100%;
      }
      #resetAllButton:hover {
          background: #d32f2f;
      }
      
      @media (max-width: 600px) {
          #controls {
              width: 90%;
              left: 5%;
          }
          #globalParameters {
              flex-direction: column;
              gap: 5px;
          }
          #globalParameters input {
              width: 100%;
          }
          .planet-control label .fieldName {
              width: 100px;
          }
      }
  </style>
</head>
<body>
  <div id="globalControls">
      <button id="toggleControls" onclick="toggleControls()">‚¨Ö</button>
  </div>
  <div id="globalParameters">
      <label style="display: flex; align-items: center; gap: 5px; color: #fff;">
          <span>‚è± Escala de Tiempo: <span id="timeScaleValue">1</span></span>
          <input type="range" id="timeScale" min="0.01" max="1000" step="0.1" value="1" style="width:150px;">
      </label>
      <div id="simTimeDisplay">Tiempo transcurrido: 0 a√±os, 0 d√≠as, 0 horas, 0 minutos, 0 segundos</div>
      <label style="display: flex; align-items: center; gap: 5px; color: #fff;">
          <span>ùê∫:</span>
          <input type="number" id="gravitationalConstant" min="1e-12" max="1e-10" step="1e-13" value="6.67430e-11" style="width:150px;">
      </label>
  </div>
  <div id="globalActions">
      <button onclick="pauseSimulation()" title="Pausar">‚è∏</button>
      <button onclick="resumeSimulation()" title="Reanudar">‚ñ∂</button>
      <button onclick="resetSimulation()" title="Reiniciar">‚ü≤</button>
      <button onclick="fitAllPlanets()" title="Ver todo">üåê</button>
  </div>
  <div id="controls">
      <h2>Control del Sistema Solar</h2>
      <div class="control-group">
          <h2>Control del Sol</h2>
          <label><span class="fieldName">Radio del Sol (km):</span>
              <input type="number" id="sunRadius" value="696000" step="1000" onkeydown="if(event.key==='Enter') updateSunProperties()">
          </label>
          <label><span class="fieldName">Densidad del Sol:</span>
              <input type="number" id="sunDensity" value="1408" step="1" onkeydown="if(event.key==='Enter') updateSunProperties()">
          </label>
          <button onclick="updateSunProperties()">Actualizar Sol</button>
          <!-- Bot√≥n para enfocar el Sol -->
          <button onclick="focusOnSun()" title="Foco en el Sol">üëÅÔ∏è</button>
      </div>
      <div class="control-group">
          <h2>Control de Planetas</h2>
          <div id="planetControls"></div>
          <!-- Bot√≥n para reiniciar los valores por defecto de TODOS los planetas -->
          <button id="resetAllButton" onclick="resetDefaultsAll()">Resetear todos</button>
      </div>
      <div class="add-planet">
          <h2>Agregar Planeta</h2>
          <label><span class="fieldName">Nombre:</span>
              <input type="text" id="newPlanetName" value="NuevoPlaneta">
          </label>
          <label><span class="fieldName">Radio (km):</span>
              <input type="number" id="newPlanetRadius" value="6000" step="1">
          </label>
          <label><span class="fieldName">Densidad (kg/m¬≥):</span>
              <input type="number" id="newPlanetDensity" value="5500" step="1">
          </label>
          <label><span class="fieldName">Distancia al Sol (km):</span>
              <input type="number" id="newPlanetDistance" value="150e6" step="1e5">
          </label>
          <label><span class="fieldName">Inclinaci√≥n (¬∞):</span>
              <input type="number" id="newPlanetInclination" value="0" step="0.1">
          </label>
          <label><span class="fieldName">Longitud del Nodo (¬∞):</span>
              <input type="number" id="newPlanetLongitude" value="90" step="0.1">
          </label>
          <button onclick="addPlanet()">Agregar Planeta</button>
      </div>
  </div>
  <div id="infoWindow">
      <button class="closeBtn" onclick="closeInfoWindow()">X</button>
      <div id="infoContent"></div>
  </div>
  <div id="planetInfo"></div>
  <script>
      // Variables globales
      let infoWindowClosed = false; // Se activa cuando se presiona X y se mantiene hasta un nuevo foco
      let isDragging = false; // Para detectar arrastre en la c√°mara

      // Definir la funci√≥n toggleControls de forma global
      function toggleControls() {
          let controlsDiv = document.getElementById("controls");
          if (controlsDiv.classList.contains("hidden")) {
              controlsDiv.classList.remove("hidden");
          } else {
              controlsDiv.classList.add("hidden");
          }
      }
      
      // Variable global para acumular el tiempo simulado (en segundos)
      let simulationTime = 0;
      
      // Funci√≥n para convertir segundos a a√±os, d√≠as, horas, minutos y segundos
      function formatSimTime(seconds) {
          const secondsPerYear = 86400 * 365;
          const secondsPerDay = 86400;
          const secondsPerHour = 3600;
          const secondsPerMinute = 60;
          let years = Math.floor(seconds / secondsPerYear);
          let rem = seconds % secondsPerYear;
          let days = Math.floor(rem / secondsPerDay);
          rem %= secondsPerDay;
          let hours = Math.floor(rem / secondsPerHour);
          rem %= secondsPerHour;
          let minutes = Math.floor(rem / secondsPerMinute);
          let secs = Math.floor(rem % secondsPerMinute);
          return `${years} a√±os, ${days} d√≠as, ${hours} horas, ${minutes} minutos, ${secs} segundos`;
      }
      
      function updateSimTimeDisplay() {
          document.getElementById("simTimeDisplay").innerText = "Tiempo transcurrido: " + formatSimTime(simulationTime);
      }
      
      // Funci√≥n getTemperature (definida globalmente)
      function getTemperature(p) {
          if (p.mesh === sun) return "5778 K";
          let currentDistance_m = p.mesh.position.length() * distanceScale;
          let currentDistance_km = currentDistance_m / 1000;
          let d_AU = currentDistance_km / 149600000;
          let T = 288 * Math.pow(1/d_AU, 0.5) - 273;
          return T.toFixed(1) + " ¬∞C";
      }
      
      // Asignamos funciones al √°mbito global para ser llamadas desde el HTML
      window.toggleControls = toggleControls;
      window.focusOnPlanet = focusOnPlanet;
      
      // Texturas para planetas conocidos
      const planetTextures = {
          "Mercurio": "8k_mercury.jpg",
          "Venus": "8k_venus_surface.jpg",
          "Marte": "8k_mars.jpg",
          "J√∫piter": "8k_jupiter.jpg",
          "Saturno": "8k_saturn.jpg",
          "Urano": "2k_uranus.jpg",
          "Neptuno": "2k_neptune.jpg"
      };
      // Texturas para planetas nuevos aleatorios
      const randomTextures = [
          "4k_ceres_fictional.jpg",
          "4k_haumea_fictional.jpg",
          "4k_makemake_fictional.jpg",
          "4k_eris_fictional.jpg"
      ];
      
      // Datos base de planetas (rotationSpeed en radianes/segundo real)
      let planetDataGlobal = [
          { name: "Mercurio", radius: 2439.7, density: 5427,  distance: 57.9e6,  inclination: 7,    longitude: 0,   rotationSpeed: 2*Math.PI/1407.6 },
          { name: "Venus",    radius: 6051.8, density: 5243,  distance: 108.2e6, inclination: 3.4,  longitude: 45,  rotationSpeed: 2*Math.PI/5832.5 },
          { name: "Tierra",   radius: 6371,   density: 5514,  distance: 149.6e6, inclination: 0,    longitude: 90,  rotationSpeed: 2*Math.PI/86400 },
          { name: "Marte",    radius: 3389.5, density: 3933,  distance: 227.9e6, inclination: 1.85, longitude: 135, rotationSpeed: 2*Math.PI/88642 },
          { name: "J√∫piter",  radius: 69911,  density: 1326,  distance: 778.5e6, inclination: 1.304, longitude: 210, rotationSpeed: 2*Math.PI/35730 },
          { name: "Saturno",  radius: 58232,  density: 687,   distance: 1.433e9, inclination: 2.485, longitude: 250, rotationSpeed: 2*Math.PI/37800 },
          { name: "Urano",    radius: 25362,  density: 1271,  distance: 2.872e9, inclination: 0.773, longitude: 80,  rotationSpeed: 2*Math.PI/62000 },
          { name: "Neptuno",  radius: 24622,  density: 1638,  distance: 4.495e9, inclination: 1.77,  longitude: 300, rotationSpeed: 2*Math.PI/57996 }
      ];
      let defaultPlanetData = JSON.parse(JSON.stringify(planetDataGlobal));
      
      let scene, camera, renderer, controls;
      let planets = []; // Cada objeto: { mesh, velocity, trail, data, initialPosition, initialVelocity }
      let sun, paused = false;
      let G = 6.67430e-11;
      let timeScale = 1;
      let focusedPlanet = null;
      let viewMode = "normal";
      
      const distanceScale = 1e9;
      const sizeScale = 1000;
      const sunSizeScale = 5;
      
      // Usamos un THREE.Clock para medir el tiempo real entre frames
      let clock = new THREE.Clock();
      
      function calcularMasa(radioKm, densidad) {
          let radioM = radioKm * 1000;
          return (4/3) * Math.PI * Math.pow(radioM, 3) * densidad;
      }
      
      function init() {
          scene = new THREE.Scene();
          const textureLoader = new THREE.TextureLoader();
          scene.background = textureLoader.load('textures/galaxy_starfield.png');
  
          let maxPlanetDistance = Math.max(...planetDataGlobal.map(d => (d.distance * 1000) / distanceScale));
          camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, maxPlanetDistance * 3);
          camera.position.set(0, 150, 300);
  
          renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(window.devicePixelRatio);
          document.body.appendChild(renderer.domElement);
  
          controls = new THREE.OrbitControls(camera, renderer.domElement);
          controls.enableDamping = true;
          controls.dampingFactor = 0.05;
          controls.rotateSpeed = 0.5;
          controls.minDistance = 10;
          // Eventos para detectar arrastre
          controls.addEventListener('start', () => { isDragging = true; });
          controls.addEventListener('end', () => { 
              isDragging = false; 
              // Si se ha enfocado previamente y la infoWindow no se cerr√≥ manualmente, se actualiza
              updateFocusedInfoWindow(); 
          });
          controls.addEventListener('change', function() {
              if(focusedPlanet) {
                  controls.target.copy(focusedPlanet.mesh.position);
              }
          });
  
          const ambientLight = new THREE.AmbientLight(0x333333);
          scene.add(ambientLight);
          const pointLight = new THREE.PointLight(0xffffff, 2, 1000);
          scene.add(pointLight);
  
          window.addEventListener("resize", onWindowResize, false);
          window.addEventListener("keydown", onKeyDown, false);
  
          simulationTime = 0;
          updateSimTimeDisplay();
  
          createSolarSystem();
          animate();
  
          renderer.domElement.addEventListener('click', onDocumentMouseDown, false);
  
          setInterval(updateSimTimeDisplay, 1000);
      }
      
      function createSolarSystem() {
          planets.forEach(p => {
              if(p && p.mesh) {
                  scene.remove(p.mesh);
                  scene.remove(p.trail);
              }
          });
          planets = [];
          if (sun) scene.remove(sun);
  
          let sunRadiusKm = parseFloat(document.getElementById("sunRadius").value);
          let sunDensity = parseFloat(document.getElementById("sunDensity").value);
          let sunMass = calcularMasa(sunRadiusKm, sunDensity);
          let visualSunRadius = (sunRadiusKm * 1000 / distanceScale) * sunSizeScale;
  
          let sunGeometry = new THREE.SphereGeometry(visualSunRadius, 64, 64);
          const textureLoader = new THREE.TextureLoader();
          let sunTexture = textureLoader.load('textures/2k_sun.jpg');
          sunTexture.format = THREE.RGBFormat;
          let sunMaterial = new THREE.MeshPhongMaterial({
              map: sunTexture,
              emissive: 0xffffff,
              emissiveMap: sunTexture,
              emissiveIntensity: 1.0,
              shininess: 10,
              transparent: false,
              opacity: 1,
              alphaTest: 0.1
          });
          sun = new THREE.Mesh(sunGeometry, sunMaterial);
          sun.position.set(0, 0, 0);
          sun.mass = sunMass;
          sun.radiusKm = sunRadiusKm;
          sun.density = sunDensity;
          let sunLight = new THREE.PointLight(0xffffff, 2, 1000);
          sun.add(sunLight);
          scene.add(sun);
  
          planetDataGlobal.forEach((data, index) => {
              addPlanetToScene(data);
          });
          updatePlanetControlsUI();
      }
      
      function addPlanetToScene(data) {
          let visualDistance = (data.distance * 1000) / distanceScale;
          let visualRadius = (data.radius * 1000 / distanceScale) * sizeScale;
          let iRad = THREE.Math.degToRad(data.inclination);
          let Œ©Rad = THREE.Math.degToRad(data.longitude);
          let pos = new THREE.Vector3(
              visualDistance * Math.cos(Œ©Rad) * Math.cos(iRad),
              visualDistance * Math.sin(iRad),
              visualDistance * Math.sin(Œ©Rad) * Math.cos(iRad)
          );
          let geometry = new THREE.SphereGeometry(visualRadius, 32, 32);
          let planet;
          const textureLoader = new THREE.TextureLoader();
          
          if(data.name === "Tierra") {
              let dayTexture = textureLoader.load('textures/8k_earth_daymap.jpg');
              dayTexture.format = THREE.RGBFormat;
              let nightTexture = textureLoader.load('textures/8k_earth_nightmap.jpg');
              nightTexture.format = THREE.RGBFormat;
              let localLightDir = new THREE.Vector3().subVectors(sun.position, pos).normalize();
              let earthUniforms = {
                  mapDay: { value: dayTexture },
                  mapNight: { value: nightTexture },
                  lightDirection: { value: localLightDir }
              };
              let earthMaterial = new THREE.ShaderMaterial({
                  uniforms: earthUniforms,
                  vertexShader: `
                      varying vec2 vUv;
                      varying vec3 vNormal;
                      void main() {
                          vUv = uv;
                          vNormal = normal;
                          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                      }
                  `,
                  fragmentShader: `
                      uniform sampler2D mapDay;
                      uniform sampler2D mapNight;
                      uniform vec3 lightDirection;
                      varying vec2 vUv;
                      varying vec3 vNormal;
                      void main() {
                          float factor = dot(normalize(vNormal), normalize(lightDirection));
                          float stepVal = step(0.0, factor);
                          vec4 color = mix(texture2D(mapNight, vUv), texture2D(mapDay, vUv), stepVal);
                          gl_FragColor = color;
                      }
                  `,
                  transparent: false
              });
              planet = new THREE.Mesh(geometry, earthMaterial);
              planet.name = data.name;
          } else if(planetTextures[data.name]) {
              let textureFile = planetTextures[data.name];
              let tex = textureLoader.load('textures/' + textureFile);
              tex.format = THREE.RGBFormat;
              let material = new THREE.MeshPhongMaterial({
                  map: tex,
                  transparent: false,
                  opacity: 1,
                  alphaTest: 0.1,
                  shininess: 50
              });
              planet = new THREE.Mesh(geometry, material);
              planet.name = data.name;
          } else {
              let randomIndex = Math.floor(Math.random() * randomTextures.length);
              let tex = textureLoader.load('textures/' + randomTextures[randomIndex]);
              tex.format = THREE.RGBFormat;
              let material = new THREE.MeshPhongMaterial({
                  map: tex,
                  transparent: false,
                  opacity: 1,
                  alphaTest: 0.1,
                  shininess: 50
              });
              planet = new THREE.Mesh(geometry, material);
              planet.name = data.name;
          }
  
          planet.position.copy(pos);
          planet.radiusKm = data.radius;
          planet.density = data.density;
          planet.mass = calcularMasa(data.radius, data.density);
          planet.initialDistance = visualDistance;
  
          let rMetros = data.distance * 1000;
          let vOrbital = Math.sqrt(G * sun.mass / rMetros);
          let normalVec = new THREE.Vector3(
              -Math.sin(Œ©Rad) * Math.sin(iRad),
              Math.cos(iRad),
              Math.cos(Œ©Rad) * Math.sin(iRad)
          ).normalize();
          let velDir = new THREE.Vector3().crossVectors(normalVec, pos).normalize();
          let velocity = velDir.multiplyScalar(vOrbital / distanceScale);
  
          let trailGeometry = new THREE.BufferGeometry();
          let trailMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
          let trail = new THREE.Line(trailGeometry, trailMaterial);
          trail.points = [];
  
          scene.add(planet);
          scene.add(trail);
          planets.push({ 
              mesh: planet, 
              velocity: velocity, 
              trail: trail, 
              initialPosition: planet.position.clone(), 
              initialVelocity: velocity.clone(),
              data: Object.assign({}, data)
          });
  
          if(data.name === "Saturno") {
              let ringInnerRadius = visualRadius * 1.2;
              let ringOuterRadius = visualRadius * 2.0;
              let ringGeometry = new THREE.RingGeometry(ringInnerRadius, ringOuterRadius, 64);
              ringGeometry.rotateX(-Math.PI / 2);
              let ringTexture = textureLoader.load('textures/8k_saturn_ring_alpha.png');
              ringTexture.format = THREE.RGBFormat;
              let ringMaterial = new THREE.MeshBasicMaterial({
                  map: ringTexture,
                  side: THREE.DoubleSide,
                  transparent: true,
                  opacity: 1,
                  alphaTest: 0.1
              });
              let ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
              planet.add(ringMesh);
          }
      }
      
      // Funci√≥n para resetear TODOS los planetas a sus valores por defecto y reiniciar el contador de tiempo
      function resetDefaultsAll() {
          for (let i = 0; i < defaultPlanetData.length; i++) {
              resetDefaultsPlanet(i);
          }
          simulationTime = 0;
          updateSimTimeDisplay();
      }
      
      function updatePlanetControlsUI() {
          let html = "";
          planets.forEach((p, index) => {
              let colorHex = "#" + (p.mesh.material && p.mesh.material.color ? p.mesh.material.color.getHexString() : "ffffff");
              html += `<div class="planet-control">
                          <h3 style="color:${colorHex}; display:inline-block;">${p.mesh.name}</h3>
                          <button class="focus-btn" onclick="focusOnPlanet(${index})" title="Foco"><span>üëÅÔ∏è</span></button>
                          <button class="reset-default-btn" onclick="resetDefaultsPlanet(${index})" title="Restaurar valores por defecto">‚Üª</button>
                          
                          <label><span class="fieldName">Radio (km):</span>
                              <button type="button" class="adjust-btn" onmousedown="handleAdjust(event, 'radius${index}', 'decrement', ${index})" onmouseup="clearAdjust('radius${index}', 'decrement', ${index})" onmouseleave="clearAdjust('radius${index}', 'decrement', ${index})">‚ûñ</button>
                              <input type="number" id="radius${index}" value="${p.data.radius}" step="1" onkeydown="if(event.key==='Enter') updatePlanetProperties(${index})">
                              <button type="button" class="adjust-btn" onmousedown="handleAdjust(event, 'radius${index}', 'increment', ${index})" onmouseup="clearAdjust('radius${index}', 'increment', ${index})" onmouseleave="clearAdjust('radius${index}', 'increment', ${index})">‚ûï</button>
                          </label>
                          
                          <label><span class="fieldName">Densidad (kg/m¬≥):</span>
                              <button type="button" class="adjust-btn" onmousedown="handleAdjust(event, 'density${index}', 'decrement', ${index})" onmouseup="clearAdjust('density${index}', 'decrement', ${index})" onmouseleave="clearAdjust('density${index}', 'decrement', ${index})">‚ûñ</button>
                              <input type="number" id="density${index}" value="${p.data.density}" step="1" onkeydown="if(event.key==='Enter') updatePlanetProperties(${index})">
                              <button type="button" class="adjust-btn" onmousedown="handleAdjust(event, 'density${index}', 'increment', ${index})" onmouseup="clearAdjust('density${index}', 'increment', ${index})" onmouseleave="clearAdjust('density${index}', 'increment', ${index})">‚ûï</button>
                          </label>
                          
                          <label><span class="fieldName">Distancia (km):</span>
                              <button type="button" class="adjust-btn" onmousedown="handleAdjust(event, 'distance${index}', 'decrement', ${index})" onmouseup="clearAdjust('distance${index}', 'decrement', ${index})" onmouseleave="clearAdjust('distance${index}', 'decrement', ${index})">‚ûñ</button>
                              <input type="number" id="distance${index}" value="${p.data.distance}" step="1e5" onkeydown="if(event.key==='Enter') updatePlanetProperties(${index})">
                              <button type="button" class="adjust-btn" onmousedown="handleAdjust(event, 'distance${index}', 'increment', ${index})" onmouseup="clearAdjust('distance${index}', 'increment', ${index})" onmouseleave="clearAdjust('distance${index}', 'increment', ${index})">‚ûï</button>
                          </label>
                          
                          <label><span class="fieldName">Inclinaci√≥n (¬∞):</span>
                              <button type="button" class="adjust-btn" onmousedown="handleAdjust(event, 'inclination${index}', 'decrement', ${index})" onmouseup="clearAdjust('inclination${index}', 'decrement', ${index})" onmouseleave="clearAdjust('inclination${index}', 'decrement', ${index})">‚ûñ</button>
                              <input type="number" id="inclination${index}" value="${p.data.inclination}" step="0.1" onkeydown="if(event.key==='Enter') updatePlanetProperties(${index})">
                              <button type="button" class="adjust-btn" onmousedown="handleAdjust(event, 'inclination${index}', 'increment', ${index})" onmouseup="clearAdjust('inclination${index}', 'increment', ${index})" onmouseleave="clearAdjust('inclination${index}', 'increment', ${index})">‚ûï</button>
                          </label>
                          
                          <label><span class="fieldName">Longitud (¬∞):</span>
                              <button type="button" class="adjust-btn" onmousedown="handleAdjust(event, 'longitude${index}', 'decrement', ${index})" onmouseup="clearAdjust('longitude${index}', 'decrement', ${index})" onmouseleave="clearAdjust('longitude${index}', 'decrement', ${index})">‚ûñ</button>
                              <input type="number" id="longitude${index}" value="${p.data.longitude}" step="0.1" onkeydown="if(event.key==='Enter') updatePlanetProperties(${index})">
                              <button type="button" class="adjust-btn" onmousedown="handleAdjust(event, 'longitude${index}', 'increment', ${index})" onmouseup="clearAdjust('longitude${index}', 'increment', ${index})" onmouseleave="clearAdjust('longitude${index}', 'increment', ${index})">‚ûï</button>
                          </label>
                          
                          <button class="delete-btn" onclick="removePlanet(${index})">Eliminar</button>
                       </div>`;
          });
          document.getElementById("planetControls").innerHTML = html;
      }
      
      let adjustTimers = {};
      
      function handleAdjust(e, fieldId, action, planetIndex) {
          let key = fieldId + "_" + planetIndex + "_" + action;
          adjustTimers[key] = {
              count: 1,
              timeout: setTimeout(() => {
                  adjustTimers[key].interval = setInterval(() => {
                      adjustTimers[key].count++;
                      adjustOnce(fieldId, action, planetIndex, adjustTimers[key].count);
                      updatePlanetProperties(planetIndex);
                  }, 100);
                  adjustTimers[key].timeout = null;
              }, 200),
              interval: null
          };
      }
      
      function clearAdjust(fieldId, action, planetIndex) {
          let key = fieldId + "_" + planetIndex + "_" + action;
          if (adjustTimers[key]) {
              if (adjustTimers[key].timeout !== null) {
                  clearTimeout(adjustTimers[key].timeout);
                  adjustOnce(fieldId, action, planetIndex);
                  updatePlanetProperties(planetIndex);
              }
              if (adjustTimers[key].interval !== null) {
                  clearInterval(adjustTimers[key].interval);
              }
              delete adjustTimers[key];
          }
      }
      
      function adjustOnce(fieldId, action, planetIndex, multiplier = 1) {
          let inputField = document.getElementById(fieldId);
          if (!inputField) return;
          if (action === 'increment') {
              inputField.stepUp(multiplier);
          } else if (action === 'decrement') {
              inputField.stepDown(multiplier);
          }
      }
      
      function updatePlanetProperties(index) {
          let inputRadius = document.getElementById(`radius${index}`);
          let inputDensity = document.getElementById(`density${index}`);
          let inputDistance = document.getElementById(`distance${index}`);
          let inputInclination = document.getElementById(`inclination${index}`);
          let inputLongitude = document.getElementById(`longitude${index}`);
          if (!inputRadius || !inputDensity || !inputDistance || !inputInclination || !inputLongitude)
              return;
          let newRadius = parseFloat(inputRadius.value);
          let newDensity = parseFloat(inputDensity.value);
          let newDistance = parseFloat(inputDistance.value);
          let newInclination = parseFloat(inputInclination.value);
          let newLongitude = parseFloat(inputLongitude.value);
  
          let planetObj = planets[index];
          planetObj.data.radius = newRadius;
          planetObj.data.density = newDensity;
          planetObj.data.distance = newDistance;
          planetObj.data.inclination = newInclination;
          planetObj.data.longitude = newLongitude;
  
          planetObj.mesh.mass = calcularMasa(newRadius, newDensity);
          planetObj.mesh.radiusKm = newRadius;
          planetObj.mesh.density = newDensity;
  
          let visualDistance = (newDistance * 1000) / distanceScale;
          let visualRadius = (newRadius * 1000 / distanceScale) * sizeScale;
          let iRad = THREE.Math.degToRad(newInclination);
          let Œ©Rad = THREE.Math.degToRad(newLongitude);
          let pos = new THREE.Vector3(
              visualDistance * Math.cos(Œ©Rad) * Math.cos(iRad),
              visualDistance * Math.sin(iRad),
              visualDistance * Math.sin(Œ©Rad) * Math.cos(iRad)
          );
          planetObj.mesh.position.copy(pos);
          let currentGeoRadius = planetObj.mesh.geometry.parameters.radius;
          planetObj.mesh.scale.setScalar(visualRadius / currentGeoRadius);
  
          let rMetros = newDistance * 1000;
          let vOrbital = Math.sqrt(G * sun.mass / rMetros);
          let normalVec = new THREE.Vector3(
              -Math.sin(Œ©Rad) * Math.sin(iRad),
              Math.cos(iRad),
              Math.cos(Œ©Rad) * Math.sin(iRad)
          ).normalize();
          let velDir = new THREE.Vector3().crossVectors(normalVec, pos).normalize();
          planetObj.velocity = velDir.multiplyScalar(vOrbital / distanceScale);
  
          updatePlanetControlsUI();
          planetObj.initialPosition.copy(planetObj.mesh.position);
          planetObj.initialVelocity.copy(planetObj.velocity);
          planetObj.trail.points = [];
          planetObj.trail.geometry.setFromPoints([]);
      }
      
      function removePlanet(index) {
          if(planets[index] && planets[index].mesh) {
              scene.remove(planets[index].mesh);
              scene.remove(planets[index].trail);
          }
          planets.splice(index, 1);
          planetDataGlobal.splice(index, 1);
          updatePlanetControlsUI();
      }
      
      function addPlanet() {
          let name = document.getElementById("newPlanetName").value;
          let radius = parseFloat(document.getElementById("newPlanetRadius").value);
          let density = parseFloat(document.getElementById("newPlanetDensity").value);
          let distance = parseFloat(document.getElementById("newPlanetDistance").value);
          let inclination = parseFloat(document.getElementById("newPlanetInclination").value);
          let longitude = parseFloat(document.getElementById("newPlanetLongitude").value);
  
          let newData = { name: name, radius: radius, density: density, distance: distance, inclination: inclination, longitude: longitude };
          planetDataGlobal.push(newData);
          addPlanetToScene(newData);
          updatePlanetControlsUI();
      }
      
      function updateSunProperties() {
          let sunRadiusKm = parseFloat(document.getElementById("sunRadius").value);
          let sunDensity = parseFloat(document.getElementById("sunDensity").value);
          let sunMass = calcularMasa(sunRadiusKm, sunDensity);
          sun.mass = sunMass;
          sun.radiusKm = sunRadiusKm;
          sun.density = sunDensity;
  
          let visualSunRadius = (sunRadiusKm * 1000 / distanceScale) * sunSizeScale;
          sun.geometry.dispose();
          sun.geometry = new THREE.SphereGeometry(visualSunRadius, 64, 64);
      }
      
      // Si se hace clic sobre el sol, se anima la c√°mara para enfocarlo y se actualiza la info
      function focusOnSun() {
          focusedPlanet = { mesh: sun, data: { temperature: "5778 K" } };
          infoWindowClosed = false; // Se reabre la info al enfocar un nuevo objeto
          new TWEEN.Tween(camera.position)
              .to({ x: sun.position.x + 50, y: sun.position.y + 50, z: sun.position.z + 50 }, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .start();
          new TWEEN.Tween(controls.target)
              .to(sun.position, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .start();
      }
      
      // Al hacer clic sobre un objeto, se anima el enfoque sobre √©l (sol o planeta)
      function onDocumentMouseDown(event) {
          // Si se est√° arrastrando, no procesamos el clic
          if(isDragging) return;
          event.preventDefault();
          let mouse = new THREE.Vector2();
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
          let raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(mouse, camera);
  
          let objects = planets.map(p => p.mesh);
          objects.push(sun);
          let intersects = raycaster.intersectObjects(objects);
          if (intersects.length > 0) {
              let clickedMesh = intersects[0].object;
              if(clickedMesh === sun) {
                  focusOnSun();
                  updateFocusedInfoWindow();
                  return;
              }
              let index = planets.findIndex(p => p.mesh === clickedMesh);
              // Si se hace clic sobre el mismo objeto en foco, se actualiza la info
              if(focusedPlanet && focusedPlanet.mesh === clickedMesh) {
                  updateFocusedInfoWindow();
                  return;
              }
              if(index >= 0) {
                  focusOnPlanet(index);
                  updateFocusedInfoWindow();
              }
          } else {
              // Si se hace clic en espacio vac√≠o, no se oculta la tarjeta si ya est√° activa
              // closeInfoWindow();  <-- Se elimina para que la infoWindow permanezca si est√° activa
          }
      }
      
      function onKeyDown(event) {
          if (event.key === "Escape") {
              focusedPlanet = null;
              viewMode = "normal";
              resetCamera();
              closeInfoWindow();
          }
      }
      
      // Usamos el clock para obtener delta (segundos reales entre frames)
      function animate() {
          requestAnimationFrame(animate);
          let delta = clock.getDelta();
          updatePlanets(delta);
          TWEEN.update();
          controls.update();
          if (sun) {
              sun.rotation.y += 0.001;
          }
          renderer.render(scene, camera);
      }
      
      function pauseSimulation() { paused = true; }
      function resumeSimulation() { paused = false; }
      
      // La infoWindow se actualiza cada 1000 ms (1 segundo real)
      setInterval(() => {
          if (focusedPlanet && focusedPlanet.mesh) {
              updateFocusedInfoWindow();
          }
      }, 1000);
      
      function updateFocusedInfoWindow() {
          let infoDiv = document.getElementById("infoWindow");
          // Si no hay foco o se ha cerrado manualmente, no se muestra la info
          if (!focusedPlanet || !focusedPlanet.mesh || infoWindowClosed) {
              infoDiv.style.display = "none";
              return;
          }
          infoDiv.style.display = "block";
          let mesh = focusedPlanet.mesh;
          let distanceReal = ((mesh.position.length() * distanceScale) / 1000).toFixed(2);
          let radiusReal = mesh.radiusKm.toFixed(2);
          let container = planets.find(p => p.mesh === mesh);
          let rotationSpeed = container && container.data.rotationSpeed !== undefined ? container.data.rotationSpeed.toExponential(2) : "N/A";
          let inclination = container ? container.data.inclination.toFixed(2) : "N/A";
          let velocityReal = container ? (container.velocity.length() * distanceScale / 1000).toFixed(2) : "N/A";
          let temperature = (mesh === sun) ? "5778 K" : getTemperature(container);
          let simTimeFormatted = formatSimTime(simulationTime);
          infoDiv.innerHTML = `
             <button class="closeBtn" onclick="closeInfoWindow()">X</button>
             <h3>${mesh.name}</h3>
             <p>Masa: ${mesh.mass.toExponential(2)} kg</p>
             <p>Radio: ${radiusReal} km</p>
             <p>Densidad: ${mesh.density ? mesh.density.toFixed(0) : "N/A"} kg/m¬≥</p>
             <p>Distancia al Sol: ${distanceReal} km</p>
             <p>Velocidad orbital: ${velocityReal} km/s</p>
             <p>Inclinaci√≥n: ${inclination} ¬∞</p>
             <p>Rotaci√≥n: ${rotationSpeed} rad/s</p>
             <p>Temperatura: ${temperature}</p>
             <p>Tiempo simulado: ${simTimeFormatted}</p>
          `;
      }
      
      function closeInfoWindow() {
          infoWindowClosed = true;
          document.getElementById("infoWindow").style.display = "none";
      }
      
      // Al hacer foco en un planeta, se anima la c√°mara para posicionarse a una distancia √≥ptima sin forzar el zoom
      function focusOnPlanet(index) {
          focusedPlanet = planets[index];
          if(!focusedPlanet || !focusedPlanet.mesh) return;
          infoWindowClosed = false; // Se reabre la info al enfocar un nuevo objeto
          let visualRadius = focusedPlanet.mesh.geometry.parameters.radius * focusedPlanet.mesh.scale.x;
          let offset = new THREE.Vector3(0, visualRadius, visualRadius * 3);
          new TWEEN.Tween(camera.position)
              .to({ 
                  x: focusedPlanet.mesh.position.x + offset.x, 
                  y: focusedPlanet.mesh.position.y + offset.y, 
                  z: focusedPlanet.mesh.position.z + offset.z 
              }, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .start();
          new TWEEN.Tween(controls.target)
              .to(focusedPlanet.mesh.position, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .start();
      }
      
      // updatePlanets usa delta real y calcula dt para √≥rbitas en segundos simulados (delta * timeScale * 86400)
      function updatePlanets(delta) {
          if (paused) return;
          let ts = document.getElementById("timeScale").value;
          timeScale = parseFloat(ts);
          document.getElementById("timeScaleValue").innerText = timeScale;
  
          G = parseFloat(document.getElementById("gravitationalConstant").value);
  
          let dt = delta * timeScale * 86400;
          simulationTime += dt;
          
          planets.forEach((p, index) => {
              if(!p || !p.mesh) return;
              let totalForce = new THREE.Vector3(0, 0, 0);
  
              let sunDirection = new THREE.Vector3().subVectors(sun.position, p.mesh.position);
              let sunDistance = sunDirection.length() * distanceScale;
              let sunForce = sunDirection.normalize().multiplyScalar(G * sun.mass * p.mesh.mass / (sunDistance * sunDistance));
              totalForce.add(sunForce);
  
              planets.forEach((otherP, otherIndex) => {
                  if (index !== otherIndex && otherP && otherP.mesh) {
                      let direction = new THREE.Vector3().subVectors(otherP.mesh.position, p.mesh.position);
                      let distance = direction.length() * distanceScale;
                      let force = direction.normalize().multiplyScalar(G * otherP.mesh.mass * p.mesh.mass / (distance * distance));
                      totalForce.add(force);
                  }
              });
  
              let acceleration = totalForce.divideScalar(p.mesh.mass);
              let accelerationVisual = acceleration.divideScalar(distanceScale);
  
              p.velocity.add(accelerationVisual.multiplyScalar(dt));
              p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));
  
              p.trail.points.push(p.mesh.position.clone());
              if (p.trail.points.length > 1000) p.trail.points.shift();
              p.trail.geometry.setFromPoints(p.trail.points);
          });
  
          // Auto-rotaci√≥n: se actualiza usando delta real * timeScale
          planets.forEach(p => {
              if(p.data.rotationSpeed !== undefined) {
                  p.mesh.rotation.y += p.data.rotationSpeed * delta * timeScale;
              }
          });
  
          // Actualizamos la direcci√≥n de la luz para la Tierra (en espacio local)
          planets.forEach(p => {
              if(p && p.mesh && p.mesh.name === "Tierra" && p.mesh.material.uniforms) {
                  let worldLightDir = new THREE.Vector3().subVectors(sun.position, p.mesh.position).normalize();
                  let localLightDir = worldLightDir.clone().applyQuaternion(p.mesh.quaternion.clone().invert());
                  p.mesh.material.uniforms.lightDirection.value = localLightDir;
              }
          });
  
          if(focusedPlanet && focusedPlanet.mesh) {
              controls.target.copy(focusedPlanet.mesh.position);
          }
      }
      
      function fitAllPlanets() {
          if (planets.length === 0) return;
          let maxDistance = 0;
          planets.forEach(p => {
              if(p && p.mesh) {
                  let d = p.mesh.position.length();
                  if (d > maxDistance) maxDistance = d;
              }
          });
          let height = maxDistance * 1.5;
          camera.far = height * 4;
          camera.updateProjectionMatrix();
  
          new TWEEN.Tween(camera.position)
              .to({ x: 0, y: height, z: height }, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .start();
          new TWEEN.Tween(controls.target)
              .to({ x: 0, y: 0, z: 0 }, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .start();
          viewMode = "cenital";
      }
      
      function resetSimulation() {
          planets.forEach((p, index) => {
              if(p && p.mesh) {
                  p.mesh.position.copy(p.initialPosition);
                  p.velocity.copy(p.initialVelocity);
                  p.trail.points = [];
                  p.trail.geometry.setFromPoints([]);
              }
          });
          focusedPlanet = null;
          simulationTime = 0;
          updateSimTimeDisplay();
          if (viewMode !== "cenital") {
              resetCamera();
          }
          closeInfoWindow();
      }
      
      function resetCamera() {
          new TWEEN.Tween(camera.position)
              .to({ x: 0, y: 150, z: 300 }, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .start();
          new TWEEN.Tween(controls.target)
              .to({ x: 0, y: 0, z: 0 }, 1000)
              .easing(TWEEN.Easing.Cubic.InOut)
              .start();
          viewMode = "normal";
      }
      
      function resetDefaultsPlanet(index) {
          let defaultData = defaultPlanetData[index];
          let p = planets[index];
          if(!p || !p.mesh) return;
          p.data.radius = defaultData.radius;
          p.data.density = defaultData.density;
          p.data.distance = defaultData.distance;
          p.data.inclination = defaultData.inclination;
          p.data.longitude = defaultData.longitude;
          planetDataGlobal[index] = Object.assign({}, defaultData);
          document.getElementById(`radius${index}`).value = defaultData.radius;
          document.getElementById(`density${index}`).value = defaultData.density;
          document.getElementById(`distance${index}`).value = defaultData.distance;
          document.getElementById(`inclination${index}`).value = defaultData.inclination;
          document.getElementById(`longitude${index}`).value = defaultData.longitude;
          updatePlanetProperties(index);
          p.initialPosition.copy(p.mesh.position);
          p.initialVelocity.copy(p.velocity);
      }
      
      function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
      }
      
      init();
      animate();
  </script>
</body>
</html>
